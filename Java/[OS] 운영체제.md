# 📃 운영체제 


<details>
<summary><strong><h3> 💡 프로세스와 스레드의 차이에 대해 설명해주세요.</h3></strong></summary>
<div markdown="1">

<br>

**프로세스**  
- 운영체제로부터 자원을 할당 받은 **작업의 단위**  
- 각 프로세스는 독립적인 메모리 영역을 할당 받는다.  

**스레드**  
- 프로세스가 할당 받은 자원을 이용하는 **실행 흐름의 단위**  
- **스택 영역과 PC 레지스터 영역만 독립적으로 할당** 받고, 나머지 영역은 동일한 프로세스 내의 스레드 간 공유 된다.  

<br>
<br>

### 📌 스레드에 스택 영역과 PC 레지스터 영역만 독립적으로 할당하는 이유가 무엇일까요?

<br>

### ✔ 스택 영역을 스레드마다 독립적으로 할당하는 이유

스택은 메소드 호출 시 전달되는 인자, 되돌아갈 주소 값 및 지역 변수 등을 저장하기 위해 사용되는 메모리 영역이다.  

스택 메모리 영역이 독립적이라는 것은 스레드 간 독립적인 함수 호출이 가능하다는 것이고, 이는 독립적인 실행 흐름을 가능하게 한다.
 
따라서 **독립적인 실행 흐름을 위한 최소 조건**으로 각 스레드에 독립된 스택 영역을 할당한다.  
 

### ✔ PC 레지스터 영역을 스레드마다 독립적으로 할당하는 이유
PC 레지스터는 CPU가 다음에 실행할 명령어의 주소를 저장한다.

여러 스레드가 하나의 PC 레지스터를 공유한다면, 한 스레드가 PC 레지스터에 새로운 명령어 주소를 저장하는 동시에 다른 스레드가 PC 레지스터의 값을 읽거나 변경하는 상황이 발생할 수 있다.
이렇게 동시에 여러 스레드가 PC 레지스터에 접근하면, 다음에 실행될 명령어의 주소를 신뢰할 수 없게 되며, 스레드들의 실행 흐름이 망가지는 등 예기치 못한 동작과 오류가 발생할 수 있다.

따라서 각 스레드에게 독립적인 PC 레지스터를 할당하여 각 **스레드가 자신의 실행 흐름을 안정적으로 유지하고, 다음에 실행할 명령어의 주소를 독립적으로 관리**할 수 있도록 한다.

<br>
<br>

### 📌 프로세스에 대해 자세히 설명해주세요.

### ✔ 프로세스

- 실행을 위해 **커널**에 등록된 작업  
    (시스템 성능 향상을 위해 커널에 의해 관리 된다.)

- 각종 자원을 요청하고, 할당 받을 수 있는 개체  
- **PCB**를 할당 받은 개체  

*자원 : 커널의 관리 하에 프로세스에게 할당/반납 되는 수동적인 개체
 
<br>
<br>

### 📌 PCB는 무엇인가요?

### ✔ PCB

- **커널 공간**에 존재한다.  

- OS는 **`프로세스 관리`** 를 위해 각 프로세스에 대한 정보를 관리하는데, 각 프로세스의 정보가
PCB에 저장된다.  
(* 프로세스 관리: 프로세스가 여러 개일 때, CPU가 스케줄링을 통해 프로세스를 관리하는 것)
- 프로세스 생성 시 생성된다.
- PCB가 관리하는 정보
    - PID(프로세스 고유 식별 번호)
    - 스케줄링 정보 (프로세스 우선 순위, CPU 점유 시간)
    - 프로세스 상태 (자원 할당 및 요청 정보)
    - 메모리 관리 정보 (page table, segment table)
    - 입출력 상태 정보 (할당 받은 입출력 장치/파일 등에 대한 정보)
    - 문맥 저장 영역(프로세스의 레지스터 상태를 저장하는 공간)
    - `Linked List` 방식으로 관리된다.
        - PCB List Head에 PCB가 생성될 때마다 붙게 된다.
        - 주소 값으로 연결이 이루어져 있는 연결 리스트이기 때문에 삽입/삭제가 용이하다.


<br>
<br>

### 📌 스레드는 PCB를 가지고 있을까요?

<br>

    🔥 스레드는 PCB를 갖고 있지 않다. 

    스레드는 프로세스 내에서 실행되는 실행 흐름의 단위로, PCB는 프로세스 단위로 생성되고 관리되는 자료구조이다.

<br>

여러 개의 스레드가 하나의 프로세스 내에서 동작하면, 모든 스레드는 동일한 프로세스의 자원을 공유하게 된다.   
따라서 스레드는 **프로세스 내부의 메모리 영역을 공유**하고, 프로세스가 할당 받은 PCB를 공유하여 프로세스의 상태를 스레드들이 함께 사용한다.

즉, 프로세스의 PCB에는 프로세스 자체의 정보와 상태를 저장하지만, 스레드는 프로세스 내에서 실행되므로 프로세스 자체와   
밀접하게 연관되어 있어 별도의 PCB를 가질 필요가 없다.

<br>
<br>


### 📌 멀티 프로세스와 멀티 스레드의 특징에 대해 설명해주세요.
<br>

### ✔ 멀티 프로세스

- 각 프로세스는 독립적인 메모리 공간을 가지기 때문에 서로 영향을 주지 않고 실행 된다.     
    즉, 한 프로세스의 오류나 비정상 종료가 다른 프로세스에 영향을 미치지 않는다.  

- 프로세스 간 데이터를 주고받기 위해서는 별도의 **IPC** 기법을 사용해야 하며, 이로 인해 오버 헤드가 발생한다.
- 각 프로세스마다 메모리 주소 체계가 다르기 때문에, 프로세스 컨텍스트 스위칭시 메모리 관련 처리가 따로 필요하여 오버 헤드가 비교적 크다.


### ✔ 멀티 프로세스

- 스레드는 하나의 프로세스 내에서 동작하며, 주소 공간과 자원을 공유한다.  
    따라서 데이터 공유가 간편하고, IPC 없이도 쓰레드 간 데이터를 주고받을 수 있습니다.

- 같은 프로세스에 속하는 스레드는 메모리 영역을 공유하기 때문에, **스레드 컨텍스트 스위칭** 시
메모리 관련 처리가 따로 필요하지 않아 오버 헤드가 비교적 적다.

-  공유된 자원에 대한 접근과 변경을 적절하게 관리하지 않으면 데드락과 같은 **동기화 문제**가 발생할 수 있다.


<br>
<br>

### 📌 멀티 스레드의 동시성과 병렬성을 설명해주세요.

### ✔ 동시성
**싱글 코어**에서 멀티스레드를 동작시키기 위한 방식으로,   
멀티태스킹을 위해 여러 개의 스레드가 **`번갈아가면서 실행되는 성질`** 을 말한다.   
(동시에 실행하는 것처럼 보이지만 **사실은 번갈아가며 실행** 하고 있는 것임)

### ✔ 병렬성
**멀티 코어**에서 멀티스레드를 동작시키는 방식으로,   
한 개 이상의 스레드를 포함하는
각 코어들이 '동시에' 실행되는 성질을 말한다.

![Alt text](<Untitled (19).png>)
</div>
</details>

<details>
<summary><strong><h3> 💡 데드락(Deadlock)에 대해 설명해주세요.</h3></strong></summary>
<div markdown="1">
<br>

    멀티 스레드 또는 멀티 프로세스 환경에서 발생하는 동기화 문제로, 
    자원을 점유한 상태에서 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황을 말한다.

![Alt text](image-13.png)

프로세스 1과 2가 자원1, 2를 모두 얻어야 한다고 가정해보자

t1: 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음  
t2: 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림  
→ **🔥 데드락**

<br>
<br>

### 📌 데드락이 발생하는 조건을 설명해주세요.

다음 네 가지 조건을 **동시에** 충족해야 한다.

- **상호 배제(Mutual Exclusion)**  
  리소스는 한 번에 하나의 프로세스 또는 스레드만이 사용할 수 있어야 한다.   
  즉, 한 프로세스 또는 스레드가 리소스를 사용 중인 경우, 다른 프로세스나 스레드는 해당 리소스에 접근할 수 없어야 한다.  

- **점유 대기(Hold and Wait)**   
  하나 이상의 리소스를 점유한 상태에서 다른 리소스를 기다리는 상태여야 한다.   
  즉, 프로세스나 스레드가 이미 리소스를 하나 이상 가지고 있으면서 또 다른 리소스를 얻기 위해 대기하고 있어야 합니다.

- **비선점(Non-Preemption)**   
  프로세스나 스레드가 얻은 리소스를 다른 프로세스나 스레드가 강제로 빼앗을 수 없어야 한다.  
    리소스는 해당 프로세스나 스레드가 명시적으로 릴리스해야만 해제된다.    

- **순환 대기(Circular Wait)**   
  두 개 이상의 프로세스나 스레드가 서로가 서로의 리소스를 기다리고 있어야 한다.  
   즉, 사이클 형태로 리소스가 대기 상태에 있어야 한다.  


<br>
<br>

### 📌 데드락은 어떻게 해결할 수 있을까요?

<br>

    - 데드락 예방
    - 데드락 회피
    - 데드락 탐지 및 복구

<br>

### ✅ 데드락 예방
- **데드락 발생 필요 조건 4가지** 중 **하나를 제거**함으로써 데드락을 예방한다.  

- 데드락이 **절대 발생하지 않도록** 하는 방법이다.
- 심각한 자원 낭비가 발생하므로, **비현실적인** 방법이다.

### **상호 배제(Mutual Exclusion) 조건 제거**  
  - **모든 자원**에 대해, **공유**를 허용한다.  
  - **현실적으로 불가능**한 방법  
  
### **점유 대기(Hold and Wait) 조건 제거**
  - 필요한 자원을 **한번에 모두 할당**한다.
  - **자원이 필요하지 않은 순간에도 점유**하고 있으므로, **자원 낭비**가 발생한다.
  - 무한 대기 현상이 발생할 수 있다.

### **비선점(Non-Preemption) 조건 제거**  
  - **모든 자원**에 대해, **선점**을 허용한다.
  - **현실적으로 불가능**한 방법  
  ( ⇒ 프로세스가 할당 받을 수 없는 자원을 요청하는 경우,
           해당 프로세스가 가지고 있던 자원을 모두 반납하고  
            작업을 취소하는 방법으로 유사하게 구현할 수 있으나, 이 방법 또한
           심각한 자원 낭비가 발생하므로 비현실적이다.)

### **순환 대기(Circular Wait) 조건 제거**  
  - 자원에 **순서를 부여**하고, 프로세스는 **순서의 증가 방향으로만 자원 요청**이 가능하도록 한다.
  - **자원 낭비**가 발생한다.

<br>

----
<br>

### ✅ 데드락 예방 회피

- 시스템의 **상태를 계속 감시함**으로써, 데드락 상태가 될 가능성이 있는
자원 할당 요청을 보류하여 데드락의 발생을 막을 수 있다.

- 항상 시스템을 감시하고 있어야 하므로, 오버 헤드가 크다.
- 시스템을 항상 **safe state**로 유지하는 방법이다.

  (***safe state**: 모든 프로세스가 정상적 종료 가능한 상태,  
                   safe sequence가 하나라도 존재하면 safe state이다.
                   데드락 상태가 되지 않을 수 있음을 보장한다.

  ***unsafe state**: 데드락 상태가 될 가능성이 있는 상태,
                     반드시 데드락이 발생한다는 의미는 아니다.)

- safe state를 유지하기 위해 **사용되지 않는 자원이 존재한다.**
- 가정이 성립되기 어렵다. 즉, **비현실적**이다.


<br>

**가정**
- 프로세스의 수가 고정됨
- 자원의 수와 종류가 고정됨
- 프로세스가 요구하는 자원 및 최대 수량을 알고 있음
- 프로세스는 자원을 사용 후 반드시 반납함

<br>

### **다익스트라 은행원 알고리즘**
    - 데드락 회피를 위한 간단한 이론적 기법
    - 가정 : 한 종류의 자원이 여러 개 존재
    - 목표 : 시스템을 항상 safe state로 유지
    - 현재 상태에서 safe sequence가 하나라도 존재하면, safe state임

<br>

### **헤버만 알고리즘**
    - 다익스트라 은행원 알고리즘의 확장
    - 가정 : 여러 종류의 자원이 여러 개 존대
    - 목표 : 시스템을 항상 safe state로 유지

<br>

----

<br>

### ✅ 데드락 탐지

- 데드락 방지를 위한 사전 작업을 하지 않는다. 즉, **데드락이 발생할 수 있다.**

- **주기적으로 데드락 발생 여부를 확인**한다.  
  (시스템이 데드락 상태인지, 어떤 프로세스가 데드락 상태인지)

- **Resource Allocation Graph (RAG)** 를 사용한다.
- 검사 주기에 영향을 받는다.
- 노드의 수가 많은 경우, 오버 헤드가 크다.

<br>

### **Graph reduction procedure**
  1. 필요한 자원을 모두 할당 받을 수 있는 프로세스(Unblocked Process)에 연결된 모든 edge를 제거한다.  
  2. 더 이상 Unblocked Process가 없을 때까지 1번을 반복한다.  
  3. 최종 그래프에서   
     a.  **모든 edge가 제거되어 있다면**    
        ⇒ 현재 상태에서 **데드락이 없음**을 알 수 있다.  

     b. **일부 edge가 남아있다면**  
        ⇒  현재 상태에 **데드락이 존재함**을 알 수 있다.

<br>

### 데드락 회피 vs 데드락 탐지

**데드락 회피**

- 앞으로 일어날 일을 고려하여, 최악의 경우를 생각한다.
- 데드락이 발생하지 않음

**데드락 탐지**

- 현재 상태만을 고려하여, 최선의 경우를 생각한다.
- 데드락 발생 시, 회복 과정이 필요하다.

<br>

----

<br>

### ✅ 데드락 회복

데드락을 탐지한 후 **해결**하는 과정

- **프로세스 종료**
    - 데드락 상태에 있는 프로세스를 종료시킨다.
    - 강제 종료된 프로세스는 이후 재시작된다.  

    <br>

- **자원 선점**
    - 데드락 상태를 해결하기 위해 선점할 자원을 선택한다.
    - 선택된 자원을 가지고 있는 프로세스에게서 해당 자원을 빼앗는다.  
    ⇒  자원을 빼앗긴 프로세스는 강제 종료된다.

<br>   

프로세스의 수행 중 특정 지점(**check point**)마다 **context**를 저장한다.  
프로세스가 강제 종료된 후 가장 최근의 **check point**에서 재시작한다.(**Roll back**)  

<br>

----

### ✅ 데드락 무시 

### +) 💡 왜 현대의 OS는 데드락을 처리하지 않을까요?

- 데드락이 일어나지 않는다고 생각하고 **아무런 조치도 취하지 않는다.**
- 데드락이 매우 드물게 발생하므로, **데드락에 대한 조치 자체가 더 큰 오버 헤드**일 수 있기 때문이다.
- 만약 시스템에 데드락이 발생한 경우, 시스템이 비정상적으로 작동하는 것을 **사람이 느낀 후 직접 프로세스를 종료**하는 방법 등으로 대처한다.
- Unix, Windows 등 **대부분의 범용 OS가 채택하고 있는 방법**이다.

<br>

</div>
</details>

<details>
<summary><strong><h3> 💡 프로세스 주소 공간에 대해 설명해 주세요.</h3></strong></summary>
<div markdown="1">

<br>


</div>
</details>

<details>
<summary><strong><h3> 💡 프로세스 주소 공간에 대해 설명해주세요.</h3></strong></summary>
<div markdown="1">
  
<br>

+)  

    ✅ 초기화 하지 않은 변수들은 어디에 저장될까요?    
    ✅ 일반적인 주소 공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 
        그렇지 않다면, 그 크기는 각각 언제 결정될까요?  


  <br>

  프로세스 주소 공간은 **하나의 프로세스가 실행되기 위해 할당된 가상 메모리 주소의 집합**을 의미한다.

  가상 메모리 주소 공간은 해당 프로세스가 실행되는 동안 프로세스에게 독립적으로 제공되며, 실제 물리적인 메모리와는 분리되어 있다.

  ![Alt text](<Untitled (20).png>)


### 1. **코드 영역 (Text 영역)**
  - 실행할 프로그램의 **명령어**들이 저장되는 영역

  - 코드 영역은 실행 파일로부터 읽혀지고, **Read-Only**으로 설정된다.
  - CPU는 코드 영역에 있는 명령어들을 하나씩 가져와 실행한다.
  
<br>

### 2. **데이터 영역 (Data 영역 및 BSS 영역)**
  - **전역 변수**와 **정적 변수**가 저장되는 영역

  - 프로그램의 시작과 함께 할당되며, 프로그램이 종료될 때 소멸된다.
  - 프로그램 실행 중에 변수의 값이 얼마든지 수정될 수 있기 때문에, **Read-Write**로 설정된다.
  - 초기화 된 변수는 Data 영역에, **초기화 되지 않은 변수는 BSS(Block Started by Symbol) 영역**에 저장된다.  

    ⇒ BSS 영역에 할당된 초기화 되지 않은 변수들은 프로그램이 실행되기 전에 0 또는 null 값으로 자동으로 초기화 된다.   

    이때 초기화되지 않은 변수들은 명시적으로 초기 값을 가지고 있지 않으므로 실제 값이 필요하지 않기 때문에, 해당 변수들은 초기화되기 전까지 메모리 공간만 할당되면 된다.  

    변수들이 0 또는 null로 초기화되는 과정은 프로그램 실행 시에 자동으로 이루어지기 때문에 
    BSS 영역을 구분하여 사용하는 것이 메모리 사용 측면에서 더욱 효율적이다.

<br>

### 3. **힙 영역**
  - **동적으로 할당되는 데이터**가 저장되는 영역

  - 프로그램 실행 중에 동적으로 메모리를 할당하고 해제하는데 사용되며,
    힙 영역에 할당된 메모리는 프로그램이 명시적으로 해제하기 전까지 지속적으로 유지된다.
  - 메모리의 **낮은 주소**에서 **높은 주소**로 할당된다.
  - **런타임**에 크기가 결정된다.  
     ⇒ 힙 영역은 **동적으로 메모리를 관리**하는 영역이기 때문에 잘못된 메모리 할당 크기, 힙 메모리 관리 오류, 힙 메모리 접근 오류 등으로 인해 **다른 영역을 침범**하게 되는 경우 `Heap Overflow`가 발생한다.

<br>

### 4. **스택 영역**
  - 함수 호출과 관련된 지역 변수, 매개변수, 함수의 반환 주소 등이 저장되는 영역

  - 함수가 호출될 때마다 스택 프레임이 생성되고, 함수의 실행이 끝나면 해당 스택 프레임이 제거된다.
  - 메모리의 **높은 주소**에서 **낮은 주소**로 할당된다.
  - **컴파일 타임**에 크기가 결정된다.       
    ⇒ 컴파일 타임에 크기가 결정되기 때문에 **무한히 할당 할 수 없다.**  
    
    ⇒ 재귀 호출의 깊이가 매우 깊거나, 함수 내부에서 큰 크기의 배열이나 많은 지역 변수를 선언하는 경우에 **`Stack Overflow`** 가 발생할 수 있다.


<br>

### 📌 Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
  
### 📌 스택 영역과 힙 영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? &nbsp; &nbsp; &nbsp; 만약 그렇다면, 각 주소 공간의 동작과정과 연계해서 설명해 주세요.
</div>
</details>